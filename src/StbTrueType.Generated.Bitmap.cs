// Generated by Sichem at 07.03.2020 14:32:25

using System;
using System.Runtime.InteropServices;

namespace StbTrueTypeSharp
{
	unsafe partial class StbTrueType
	{
		[StructLayout(LayoutKind.Sequential)]
		public struct stbtt__bitmap
		{
			public int w;
			public int h;
			public int stride;
			public byte* pixels;
		}
		public static void stbtt__handle_clipped_edge(float* scanline, int x, stbtt__active_edge* e, float x0, float y0, float x1, float y1)
		{
			if ((y0) == (y1))
				return;
			if ((y0) > (e->ey))
				return;
			if ((y1) < (e->sy))
				return;
			if ((y0) < (e->sy))
			{
				x0 += (float)((x1 - x0) * (e->sy - y0) / (y1 - y0));
				y0 = (float)(e->sy);
			}

			if ((y1) > (e->ey))
			{
				x1 += (float)((x1 - x0) * (e->ey - y1) / (y1 - y0));
				y1 = (float)(e->ey);
			}

			if ((x0 <= x) && (x1 <= x))
			{
				scanline[x] += (float)(e->direction * (y1 - y0));
			}
			else if (((x0) >= (x + 1)) && ((x1) >= (x + 1)))
			{
			}
			else
			{
				scanline[x] += (float)(e->direction * (y1 - y0) * (1 - ((x0 - x) + (x1 - x)) / 2));
			}
		}

		public static void stbtt__rasterize_sorted_edges(stbtt__bitmap* result, stbtt__edge* e, int n, int vsubsample, int off_x, int off_y, void* userdata)
		{
			stbtt__hheap hh = new stbtt__hheap();
			stbtt__active_edge* active = (null);
			int y = 0;
			int j = (int)(0);
			int i = 0;
			float* scanline_data = stackalloc float[129];
			float* scanline;
			float* scanline2;
			if ((result->w) > (64))
				scanline = (float*)(CRuntime.malloc((ulong)((result->w * 2 + 1) * sizeof(float))));
			else
				scanline = scanline_data;
			scanline2 = scanline + result->w;
			y = (int)(off_y);
			e[n].y0 = (float)((float)(off_y + result->h) + 1);
			while ((j) < (result->h))
			{
				float scan_y_top = (float)(y + 0.0f);
				float scan_y_bottom = (float)(y + 1.0f);
				stbtt__active_edge** step = &active;
				CRuntime.memset(scanline, (int)(0), (ulong)(result->w * sizeof(float)));
				CRuntime.memset(scanline2, (int)(0), (ulong)((result->w + 1) * sizeof(float)));
				while ((*step) != null)
				{
					stbtt__active_edge* z = *step;
					if (z->ey <= scan_y_top)
					{
						*step = z->next;
						z->direction = (float)(0);
						stbtt__hheap_free(&hh, z);
					}
					else
					{
						step = &((*step)->next);
					}
				} while (e->y0 <= scan_y_bottom)
				{
					if (e->y0 != e->y1)
					{
						stbtt__active_edge* z = stbtt__new_active(&hh, e, (int)(off_x), (float)(scan_y_top), userdata);
						if (z != (null))
						{
							if (((j) == (0)) && (off_y != 0))
							{
								if ((z->ey) < (scan_y_top))
								{
									z->ey = (float)(scan_y_top);
								}
							}
							z->next = active;
							active = z;
						}
					}
					++e;
				}
				if ((active) != null)
					stbtt__fill_active_edges_new(scanline, scanline2 + 1, (int)(result->w), active, (float)(scan_y_top));
				{
					float sum = (float)(0);
					for (i = (int)(0); (i) < (result->w); ++i)
					{
						float k = 0;
						int m = 0;
						sum += (float)(scanline2[i]);
						k = (float)(scanline[i] + sum);
						k = (float)((float)(CRuntime.fabs((double)(k))) * 255 + 0.5f);
						m = ((int)(k));
						if ((m) > (255))
							m = (int)(255);
						result->pixels[j * result->stride + i] = ((byte)(m));
					}
				}
				step = &active;
				while ((*step) != null)
				{
					stbtt__active_edge* z = *step;
					z->fx += (float)(z->fdx);
					step = &((*step)->next);
				}
				++y;
				++j;
			}
			stbtt__hheap_cleanup(&hh, userdata);
			if (scanline != scanline_data)
				CRuntime.free(scanline);
		}
	}
}